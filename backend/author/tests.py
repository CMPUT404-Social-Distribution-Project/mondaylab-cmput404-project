from django.test import TestCase
from .models import Author
from rest_framework.test import APITestCase, APIClient
from rest_framework_simplejwt.tokens import RefreshToken
from uuid import uuid4


class AuthorTestCase(APITestCase):
    def setUp(self):
        self.displayName = "test"
        self.password = "testtest"
        self.user_info = {'displayName': self.displayName, 'password': self.password}
        self.client = APIClient()

        # Register the mock author using /register/ endpoint as this properly setups
        # the token in the backend so that the two tokens (the token given to the client
        # and the token that the backend keeps in a "whitelist") can be checked against each
        # other. Using self.client.credentials(HTTP_AUTHORIZATION=refresh.access_token)
        # with refresh = RefreshToken.for_user(mock_author) would not work because
        # mock_author would be created with Author.objects.create_user() which does
        # not register a JWT for mock_author on the server. So what ends up happening
        # in this situation is that a token is generated by RefreshToken.for_user(mock_author)
        # but it is not registered in the server so the server says "idk what this is" and gives
        # a 401.
        response = self.client.post(f'/service/auth/register/', self.user_info , format="json")
        self.assertEqual(response.status_code, 201)
        res_data = response.data
        self.assertTrue('token' in res_data.keys())
        self.authorization = f'Bearer {res_data.get("token")}'
        self.mock_author = Author.objects.get(displayName=self.displayName)


    def testCreateAuthor(self):
        Author.objects.create(displayName="Author")
        author1 = Author.objects.get(displayName="Author")

        self.assertEqual(author1.displayName, "Author")
    
    def testGetAuthor(self):
        Author.objects.create(displayName="Author2")
        author2 = Author.objects.get(displayName="test")
        url = f'/service/authors/{author2.uuid.hex}/'

        res = self.client.get(url, format="json")
        self.assertEqual(res.status_code, 200)
        res = res.data
        # check that all the fields needed are present
        self.assertTrue('id' in res.keys())
        self.assertTrue('url' in res.keys())
        self.assertTrue('host' in res.keys())
        self.assertTrue('github' in res.keys())
        self.assertTrue('profileImage' in res.keys())
        self.assertTrue('displayName' in res.keys())
        self.assertTrue('type' in res.keys())

    def testGet301(self):
        # should get 301 
        url = f'/service/authors/{uuid4().hex}'
        res = self.client.get(url, format="json")
        self.assertEqual(res.status_code, 301)

    def testUpdateAuthorNoAuthorization(self):
        # should be able to GET author fine since method is public
        url = f'/service/authors/{self.mock_author.uuid}/'
        res = self.client.get(url, format="json")
        self.assertEqual(res.status_code, 200)

        # No authorization header added, should get 401
        update_res = self.client.post(url, {'displayName': 'AuthorPatched'})
        self.assertEqual(update_res.status_code, 401)

    def testUpdateAuthor(self):
        # update author 
        refresh, author_id = self.log_in("test", "testtest")
        self.client.credentials(
            HTTP_AUTHORIZATION='Bearer ' + refresh)
        url = f'/service/authors/{author_id}/'
        res = self.client.get(url, format="json")
        self.assertEqual(res.status_code, 200)
        # update author with new display name
        update_res = self.client.post(url, {'displayName': 'test1'}, format="json", HTTP_AUTHORIZATION=refresh)
        self.assertEqual(update_res.status_code, 202)

        # get author again and see if it really did update
        res = self.client.get(url, format="json")
        self.assertEqual(res.status_code, 200)
        self.assertEqual(res.data.get('displayName'), 'test1')
    def create_authors(self):
        # Create mock authors
        self.credentials1 = {'displayName': 'test','password': 'testtest'}
        self.client.post(f'http://localhost:8000/service/auth/register/', self.credentials1 , format="json")
        mock_author1 = Author.objects.get(displayName="test")

        return mock_author1

    def log_in(self, displayName, password):
        # Create authors
        # To get authtication
        self.client = APIClient()
        # Create 3 authors
        self.mock_author1 = self.create_authors()
        author_id= self.get_id(self.mock_author1)

        # Log in existed authors
        self.credentials = {'displayName': displayName,'password': password}
        response =self.client.post(f'http://localhost:8000/service/auth/login/', self.credentials, format="json")

        return response.data['access'], author_id

    def get_id(self, mock_author1):
        # Get uuid based on authors given
        author_id = mock_author1.uuid
        return author_id.hex



class AuthorsTestCase(TestCase):
    NUM_AUTHORS = 0    # should only show 5 authors at a time when specified

    def testGetAuthors(self):
        url = f'http://localhost:8000/service/authors/?page=1&size={self.NUM_AUTHORS}'
        Author.objects.create(displayName="Author1", password="123456789")
        Author.objects.create(displayName="Author2", password="123456789")
        Author.objects.create(displayName="Author3", password="123456789")
        Author.objects.create(displayName="Author4", password="123456789")
        Author.objects.create(displayName="Author5", password="123456789")
        Author.objects.create(displayName="Author6", password="123456789")
        

        res = self.client.get(url)
        numAuthors = len(res.data.get("items"))
        self.assertEqual(res.status_code, 200)
        self.assertEqual(numAuthors, self.NUM_AUTHORS)
        self.assertEqual(res.data.get('type'), 'authors')

        self.assertEqual(res.status_code, 200)

    def testPostAuthorsUnauthorized(self):
        # tests without authorization
        url = f'/service/authors/'
        res = self.client.post(url, format="json")
        self.assertEqual(res.status_code, 401)

